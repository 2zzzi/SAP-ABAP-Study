*&---------------------------------------------------------------------*
*& Report ZEDR05_20230411
*&---------------------------------------------------------------------*
*&
*&---------------------------------------------------------------------*
REPORT ZEDR05_20230411.

*"SELECT INTO - STRUCTURE
*DATA : BEGIN OF GS_SCARR,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID CARRNAME INTO GS_SCARR "구조체로 사용할 경우 select문을 닫아 줘야 한다.
*  FROM SCARR
*  WHERE CARRID = 'AA'. "CARRID는 SCARR데이터베이스의 필드
*
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDSELECT.
*
*CLEAR : GS_SCARR.
*
*SELECT SINGLE CARRID CARRNAME INTO ( GS_SCARR-CARRID, GS_SCARR-CARRNAME ) "WHERE 절을 통한 SELECT LINE
*  FROM SCARR
*  WHERE CARRID = 'AA'.
*
*WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*
*CLEAR : GS_SCARR.
*
*SELECT SINGLE CARRID CARRNAME INTO GS_SCARR "괄호를 없애도 알아서 들어감!
*  FROM SCARR
*  WHERE CARRID = 'AA'.
*
*WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.

*"SELECT INTO - ITAB
*
*DATA : BEGIN OF GS_SCARR,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO TABLE GT_SCARR
*  WHERE CARRID = 'AA'.
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*" INTO - ITAB > 만약에 ITAB필드와 SELECT하는 필드가 다를 경우 순서대로 인터널 테이블에 넣기 때문에 데이터가 이상해진다!
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO TABLE GT_SCARR
*  WHERE CARRID = 'AA'.
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*" INTO - ITAB > CORRESPONDING FIELDS OF
*"CORRESPONDING FIELDS OF 구문을 사용해 각각의 동일 필드 명에 맞게 값이 할당됨
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR " INTO CORRESPONDING FIELDS OF
*  WHERE CARRID = 'AA'.
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*" INTO - ITAB > APPENDING
*"인터널 테이블에 데이터 SELECT후 다른 조건의 데이터도 추가하고싶다면 다음 SELECT문에 INTO를 때리는게 아니라 APPENDING을 해줘야 데이터가 보존되고 추가가 된다.
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  APPENDING CORRESPONDING FIELDS OF TABLE GT_SCARR
**  APPENDING CORRESPONDING FIELDS OF TABLE GT_SCARR "첫번째 SELECT도 APPENDING 해줄 수 있지만 ITAB에 쓰레기값이 차있을 수도 있으니?
*  WHERE CARRID = 'AA'.
*
*  SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  APPENDING CORRESPONDING FIELDS OF TABLE GT_SCARR
*  WHERE CARRID = 'AB'.
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

" WHERE > BETWEEN A AND B
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
*  WHERE CARRID BETWEEN 'AA' AND 'BA'.
*
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*" WHERE - STRING  비교 > WHERE FIELD LIKE 'A%' "앞자리가 A로 시작하는 조건이 맞아야 불러옴
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
*  WHERE CARRID LIKE '%A'.
*
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*" WHERE - LIST VALUE > WHERE FIELD IN 조건 "IN 구문을 사용하여 여러 조건에 속한 경우의 값을 가져온다.
*"만약 추가해야되는 조건이 여러건이면?
*"번거로움을 ITAB형식으로 변경하여 범위를 받을 수 있게 하는 것이 RANGE변수임
*
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
*  WHERE CARRID IN ( 'AA', 'AC' ).
*
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*"RANGE TABLE
*RANGES GR_SCARR FOR SCARR-CARRID.
*
*DATA : BEGIN OF GS_SCARR,
*  ZCHECK TYPE C,
*  CARRID LIKE SCARR-CARRID,
*  CARRNAME LIKE SCARR-CARRNAME,
*  END OF GS_SCARR.
*
*DATA GT_SCARR LIKE TABLE OF GS_SCARR.
*
*"GR_SCARR 값 설정
*GR_SCARR-SIGN = 'I'.
*GR_SCARR-OPTION = 'EQ'.
*GR_SCARR-LOW = 'AA'.
*APPEND GR_SCARR.
*
*GR_SCARR-LOW = 'AC'.
*APPEND GR_SCARR.
*"APPEND니까 GR_SCARR 테이블에 한줄 씩 들어감. 그래서 GR_SCARR은 2줄이 되는거임.
*
*
*SELECT CARRID
*       CARRNAME
*  FROM SCARR
*  INTO CORRESPONDING FIELDS OF TABLE GT_SCARR
*  WHERE CARRID IN GR_SCARR.
*
*
*LOOP AT GT_SCARR INTO GS_SCARR.
*  WRITE :/ GS_SCARR-CARRID, GS_SCARR-CARRNAME.
*ENDLOOP.

*"GROUP BY
*DATA : BEGIN OF GS_SFLIGHT,
*  CARRID TYPE SFLIGHT-CARRID,
*  CONNID TYPE SFLIGHT-CONNID,
*  GV_AVG TYPE I,
*  END OF GS_SFLIGHT.
*DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.
*
*SELECT CARRID
*       CONNID
*       AVG( PRICE ) AS GV_AVG
*  INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
*  FROM SFLIGHT
*  GROUP BY CARRID CONNID.
*
*LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
*
*  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-GV_AVG.
*
*ENDLOOP.

*"HAVING
*DATA : BEGIN OF GS_SFLIGHT,
*  CARRID TYPE SFLIGHT-CARRID,
*  CONNID TYPE SFLIGHT-CONNID,
*  GV_AVG TYPE I,
*  END OF GS_SFLIGHT.
*DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.
*
*SELECT CARRID
*       CONNID
*       AVG( PRICE ) AS GV_AVG
*  INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
*  FROM SFLIGHT
*  GROUP BY CARRID CONNID
*  HAVING AVG( PRICE ) > 1000. "GROUP BY로 조회한 데이터중 PRICE가 1000이상인 데이터만 보고싶다면 HAVING 조건 추가
*
*LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
*
*  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-GV_AVG.
*
*ENDLOOP.

*"ORDER BY
*DATA : BEGIN OF GS_SFLIGHT,
*  CARRID TYPE SFLIGHT-CARRID,
*  CONNID TYPE SFLIGHT-CONNID,
*  GV_AVG TYPE I,
*  END OF GS_SFLIGHT.
*DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.
*
*SELECT CARRID
*       CONNID
*       AVG( PRICE ) AS GV_AVG
*  INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
*  FROM SFLIGHT
*  GROUP BY CARRID CONNID
*  HAVING AVG( PRICE ) > 1000
*  ORDER BY CARRID DESCENDING. "오름차순 내림차순을 만들고싶을때
*
*LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
*
*  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-GV_AVG.
*
*ENDLOOP.

"SUB QUERY
*DATA : BEGIN OF gs_sflight,
*         carrid TYPE sflight-carrid,
*         connid TYPE sflight-connid,
*         price  TYPE sflight-price,
*       END OF gs_sflight.
*DATA : gt_sflight LIKE TABLE OF gs_sflight.
*
*SELECT carrid connid price
*  INTO CORRESPONDING FIELDS OF TABLE gt_sflight
*  FROM sflight
*  WHERE carrid IN ( SELECT carrid
*                      FROM spfli
*                      WHERE carrid = sflight~carrid
*                      AND connid = sflight~connid )
*  AND carrid = 'AA'
*  AND connid LIKE '00%'.
*
*LOOP AT gt_sflight INTO gs_sflight.
*
*  WRITE :/ gs_sflight-carrid, gs_sflight-connid, gs_sflight-price.
*
*ENDLOOP.

*"SUB QUERY - ALIAS > 별칭 지정
*DATA : BEGIN OF GS_SFLIGHT,
*         CARRID TYPE SFLIGHT-CARRID,
*         CONNID TYPE SFLIGHT-CONNID,
*         PRICE  TYPE SFLIGHT-PRICE,
*       END OF GS_SFLIGHT.
*DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.
*
*SELECT CARRID CONNID PRICE
*  INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
*  FROM SFLIGHT AS A
*  WHERE CARRID IN ( SELECT CARRID
*                      FROM SPFLI
*                      WHERE CARRID = A~CARRID
*                      AND CONNID = A~CONNID )
*  AND CARRID = 'AA'
*  AND CONNID LIKE '00%'.
*
*LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
*
*  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-PRICE.
*
*ENDLOOP.


*"JOIN - INNER JOIN
*DATA : BEGIN OF GS_SFLIGHT,
*         CARRID TYPE SFLIGHT-CARRID,
*         CONNID TYPE SFLIGHT-CONNID,
*         CARRNAME TYPE SCARR-CARRNAME,
*       END OF GS_SFLIGHT.
*DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.
*
*SELECT A~CARRID
*  A~CONNID
*  B~CARRNAME
*  INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
*  FROM SFLIGHT AS A
*  INNER JOIN SCARR AS B
*  ON A~CARRID = B~CARRID
*  WHERE A~CARRID = 'AA'.
*
*LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
*
*  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-CARRNAME.
*
*ENDLOOP.

*"JOIN - OUTER JOIN
*DATA : BEGIN OF GS_SFLIGHT,
*         CARRID TYPE SFLIGHT-CARRID,
*         CONNID TYPE SFLIGHT-CONNID,
*         CARRNAME TYPE SCARR-CARRNAME,
*       END OF GS_SFLIGHT.
*DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.
*
*SELECT A~CARRID
*  A~CONNID
*  B~CARRNAME
*  INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
*  FROM SFLIGHT AS A
*  LEFT OUTER JOIN SCARR AS B
*  ON A~CARRID = B~CARRID
*  WHERE A~CARRID = 'AA'.
*
*LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
*
*  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-CARRNAME.
*
*ENDLOOP.

"FOR ALL ENTRIES
"JOIN과 개념은 유사하지만 ITAB과 DB를 조인함.
DATA : BEGIN OF GS_SPFLI,
         CARRID TYPE SPFLI-CARRID,
         CONNID TYPE SPFLI-CONNID,
       END OF GS_SPFLI.
DATA : GT_SPFLI LIKE TABLE OF GS_SPFLI.

DATA : BEGIN OF GS_SFLIGHT,
         CARRID TYPE SFLIGHT-CARRID,
         CONNID TYPE SFLIGHT-CARRID,
         FLDATE TYPE SFLIGHT-FLDATE,
         PRICE  TYPE SFLIGHT-PRICE,
       END OF GS_SFLIGHT.
DATA : GT_SFLIGHT LIKE TABLE OF GS_SFLIGHT.

SELECT CARRID CONNID
  FROM SPFLI
  INTO CORRESPONDING FIELDS OF TABLE GT_SPFLI
  WHERE CARRID LIKE 'A%'.

IF GT_SPFLI IS NOT INITIAL. "GT_SPFLI가 NULL값이면 FULL SCAN으로 MEMORY DUMP > 인터널 필드가 차있는지 IF문 수행
  SELECT CARRID
    CONNID
    FLDATE
    PRICE
    FROM SFLIGHT
    INTO CORRESPONDING FIELDS OF TABLE GT_SFLIGHT
    FOR ALL ENTRIES IN GT_SPFLI
    WHERE CARRID = GT_SPFLI-CARRID "인터널 테이블에 존재하는 필드만 가능하므로 LIKE, BETWEEN, IN같은 비교구문 사용 불가.
    AND CONNID = GT_SPFLI-CONNID.
ENDIF.

LOOP AT GT_SFLIGHT INTO GS_SFLIGHT.
  WRITE :/ GS_SFLIGHT-CARRID, GS_SFLIGHT-CONNID, GS_SFLIGHT-FLDATE, GS_SFLIGHT-PRICE.
ENDLOOP.